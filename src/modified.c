/**
 * Neutrino Hook CUDA Driver
*/

#include <unistd.h> // for many thing
#include <stdlib.h> // for standard library
#include <stdio.h>  // for file dump
#include <dlfcn.h>  // for loading real cuda shared library
#include <sys/stat.h> // for directory
#include <sys/wait.h> // for waiting subprocess
#include <time.h>   // for timing related

#include "common.h" // for common headers

static void* shared_lib           = NULL; // handle to real cuda driver
static char* NEUTRINO_REAL_CUDA   = NULL; // path to real cuda driver, loaded by env_var NEUTRINO_REAL_CUDA
static char* NEUTRINO_PYTHON      = NULL; // path to python exe, loaded by env_var NEUTRINO_PYTHON
static char* NEUTRINO_PROCESS_PY  = NULL; // path to process.py, loaded by env_var NEUTRINO_PROCESS_PY

// directory structure 
static char* RESULT_DIR = NULL; // env_var NEUTRINO_TRACEDIR/MM_DD_HH_MM_SS/result
static char* KERNEL_DIR = NULL; // env_var NEUTRINO_TRACEDIR/MM_DD_HH_MM_SS/kernel

// a filter to temporarily disable the tracing, motivated for disable trace in `torch.compile`, loaded by env_var `NEUTRINO_ENABLE`
static int NEUTRINO_ENABLE = 1;

/**
 * Benchmark mode, will include an additional launch after the trace kernel
 * Used to measure the kernel-level slowdown of Neutrino, disabled by default
 * @warning might cause CUDA_ERROR with in-place kernels, coupled with --filter if encountered
 *          this intrinsic of program and can not be resolved by Neutrino
 * @note benchmark_mem is a 256MB empty memory that will be cuMemSetD32 to 0
 *       which take the L2 Cache Space and Remove Previous L2 Cache Value, 
 * @cite this is inspired by Triton do_bench and Nvidia https://github.com/NVIDIA/nvbench/
 */
static int NEUTRINO_BENCHMARK = 0;
static int NEUTRINO_BENCHMARK_FLUSH_MEM_SIZE = 256e6; 
static CUdeviceptr benchmark_flush_mem = 0u; // aka NULL

// simple auto-increasing idx to distinguish kernels of the same name (Triton Autotune)
static int kernel_idx = 0;

// start time for logging, this works as rough sense of Neutrino slowdown across kernels
// and provides basic ordering of trace for later processing
static struct timespec start;

// verbose setting -> to prevent log file too large due to unimportant setting
static int VERBOSE = 0; 

// following three function are hooked for Neutrino
// and Neutrino save it here to load in init()
CUresult (*real_cuModuleLoadData)(CUmodule*, const void*) = NULL;
CUresult (*real_cuModuleGetFunction)(CUfunction*, CUmodule, const char*) = NULL;
CUresult (*real_cuLaunchKernel)(CUfunction, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, CUstream, void**, void**) = NULL;
CUresult (*real_cuMemAlloc_v2)(CUdeviceptr*, size_t) = NULL;
CUresult (*real_cuMemAllocHost_v2)(void**, size_t) = NULL;
CUresult (*real_cuMemFree_v2)(CUdeviceptr) = NULL;
CUresult (*real_cuMemcpyDtoH_v2)(void*, CUdeviceptr, size_t) = NULL;
CUresult (*real_cuMemcpyHtoD_v2)(CUdeviceptr, const void*, size_t) = NULL;
CUresult (*real_cuMemsetD32_v2)(CUdeviceptr, unsigned int, size_t) = NULL;
CUresult (*real_cuGetProcAddress_v2)(const char*, void**, int, cuuint64_t, CUdriverProcAddressQueryResult*) = NULL;
CUresult (*real_cuDeviceGetAttribute)(int*, CUdevice_attribute, CUdevice) = NULL;
CUresult (*real_cuGetErrorName)(CUresult error, const char** pStr) = NULL;
CUresult (*real_cuModuleLoad)(CUmodule* module, const char* fname) = NULL;
CUresult (*real_cuModuleLoadFatBinary)(CUmodule* module, const void* fatCubin) = NULL;
CUresult (*real_cuLaunchKernelEx)(const CUlaunchConfig* config, CUfunction f, void** kernelParams, void** extra) = NULL;
CUresult (*real_cuStreamSynchronize)(CUstream hStream) = NULL;

// helper macro to check dlopen/dlsym error
#define CHECK_DL() do {                    \
    const char *dl_error = dlerror();      \
    if (dl_error) {                        \
        fprintf(stderr, "%s\n", dl_error); \
        exit(EXIT_FAILURE);                \
    }                                      \
} while (0)

// helper macro to check cuda error
#define CUDA_CHECK(cmd) do {                    \
	CUresult result = cmd;                      \
	if (result != CUDA_SUCCESS) {               \
		const char *msg;                        \
		real_cuGetErrorName(result, &msg);      \
		printf("Neutrino fail: %s:%d '%s'\n",   \
					 __FILE__, __LINE__, msg);  \
		exit(EXIT_FAILURE);                     \
	}                                           \
} while (0)

// include auto-generated signatures for unmodified functions
// @note signature.c will be auto generated by parse.py
#include "signature.c"

/**
 * Function to initialize the environment, including
 * * init the cuda driver module via dlopen
 * * init the file system as specified above
 * * init the hashmap for binaries and CUfunction
 * * init commonly used functions like real_cuModuleLoad...
 * 
 * @note this will be called only once when any hooked driver function is called
 */
static void init(void) {
    // get environment variables
    NEUTRINO_REAL_CUDA = getenv("NEUTRINO_REAL_CUDA");
    if (NEUTRINO_REAL_CUDA == NULL) {
        fprintf(stderr, "Environmental Variable NEUTRINO_REAL_CUDA not set\n");
        exit(EXIT_FAILURE);
    }
    NEUTRINO_PYTHON = getenv("NEUTRINO_PYTHON");
    if (NEUTRINO_PYTHON == NULL) {
        fprintf(stderr, "Environmental Variable NEUTRINO_PYTHON not set\n");
        exit(EXIT_FAILURE);
    }
    NEUTRINO_PROCESS_PY = getenv("NEUTRINO_PROCESS_PY");
    if (NEUTRINO_PROCESS_PY == NULL) {
        fprintf(stderr, "Environmental Variable NEUTRINO_PROCESS_PY not set\n");
        exit(EXIT_FAILURE);
    }
    char* verbose = getenv("NEUTRINO_VERBOSE");
    if (verbose != NULL && atoi(verbose) != 0) {
        VERBOSE = 1;
    } // otherwise, default is 0
    char* benchmark = getenv("NEUTRINO_BENCHMARK");
    if (benchmark != NULL && atoi(benchmark) != 0) {
        NEUTRINO_BENCHMARK = 1;
    }
    char* NEUTRINO_TRACEDIR = getenv("NEUTRINO_TRACEDIR");
    if (NEUTRINO_TRACEDIR == NULL) {
        fprintf(stderr, "Environment Variable NEUTRINO_TRACEDIR not set\n");
        exit(EXIT_FAILURE);
    }
    // check and create folder structure
    // first create GPUMEM_TRACE_DIR
    if (access(NEUTRINO_TRACEDIR, F_OK) != 0) { // not existed or bugs
        if (mkdir(NEUTRINO_TRACEDIR, 0755) != 0) {
            perror("Can not create NEUTRINO_TRACEDIR");
            exit(EXIT_FAILURE);
        }
    }
    // generate TRACE_DIR and create if need
    char* TRACE_DIR = (char*) malloc(strlen(NEUTRINO_TRACEDIR) + 30);
    // get the current time to do
    char current_time[TIME_FORMAT_LEN];
    get_formatted_time(current_time);
    // format is time_pid -> pid to avoid multiprocess in one second (fix for PyTorch & NCCL)
    sprintf(TRACE_DIR, "%s/%s_%d", NEUTRINO_TRACEDIR, current_time, getpid());
    if (mkdir(TRACE_DIR, 0755) != 0) {
        perror("Can not create TRACE_DIR");
        exit(EXIT_FAILURE);
    }
    // create the directories and files
    RESULT_DIR = malloc(strlen(TRACE_DIR) + 8);
    sprintf(RESULT_DIR, "%s/result", TRACE_DIR);
    if (mkdir(RESULT_DIR, 0755) != 0) {
        perror("Can not create RESULT_DIR");
        exit(EXIT_FAILURE);
    }
    KERNEL_DIR = malloc(strlen(TRACE_DIR) + 8);
    sprintf(KERNEL_DIR, "%s/kernel", TRACE_DIR);
    if (mkdir(KERNEL_DIR, 0755) != 0) {
        perror("Can not create KERNEL_DIR");
        exit(EXIT_FAILURE);
    }
    fprintf(stderr, "[info] trace in %s \n", TRACE_DIR);
    char* LOG_PATH = malloc(strlen(TRACE_DIR) + 20);
    sprintf(LOG_PATH, "%s/event.log", TRACE_DIR);
    log = fopen(LOG_PATH, "a");
    if (log == NULL) {
        perror("Can open event.log");
        exit(EXIT_FAILURE);
    }
    fprintf(log, "[pid] %d\n", getpid()); // print the process id
    // get command line arguments
    char cmdpath[128], cmdline[1024];
    sprintf(cmdpath, "/proc/%d/cmdline", getpid());
    FILE *cmdfile = fopen(cmdpath, "r");
    size_t len = fread(cmdline, 1, sizeof(cmdline) - 1, cmdfile);
    if (len > 0) {
        // Replace null characters with spaces
        for (int i = 0; i < len; i++) {
            if (cmdline[i] == '\0') { 
                cmdline[i] = ' ';
            }
        }
    }
    fclose(cmdfile);
    // print the command line, helpful to correlate source code
    fprintf(log, "[cmd] %zu %s\n", len, cmdline); 
    fflush(log);
    // load real CUDA shared library
    shared_lib = dlopen(NEUTRINO_REAL_CUDA, RTLD_LAZY);
    if (!shared_lib) {
        fprintf(stderr, "%s\n", dlerror());
        exit(EXIT_FAILURE);
    }
    fprintf(log, "[info] dl %p\n", shared_lib); 
    // load directly used function of Neutrino
    real_cuModuleLoadData     = dlsym(shared_lib, "cuModuleLoadData");
    real_cuModuleGetFunction  = dlsym(shared_lib, "cuModuleGetFunction");
    real_cuLaunchKernel       = dlsym(shared_lib, "cuLaunchKernel");
    real_cuMemAlloc_v2        = dlsym(shared_lib, "cuMemAlloc_v2");
    real_cuMemAllocHost_v2    = dlsym(shared_lib, "cuMemAllocHost_v2");
    real_cuMemFree_v2         = dlsym(shared_lib, "cuMemFree_v2");
    real_cuMemcpyDtoH_v2      = dlsym(shared_lib, "cuMemcpyDtoH_v2");
    real_cuMemcpyHtoD_v2      = dlsym(shared_lib, "cuMemcpyHtoD_v2");
    real_cuMemsetD32_v2       = dlsym(shared_lib, "cuMemsetD32_v2");
    real_cuGetProcAddress_v2  = dlsym(shared_lib, "cuGetProcAddress_v2");
    real_cuDeviceGetAttribute = dlsym(shared_lib, "cuDeviceGetAttribute");
    real_cuGetErrorName       = dlsym(shared_lib, "cuGetErrorName");
    real_cuModuleLoad         = dlsym(shared_lib, "cuModuleLoad");
    real_cuModuleLoadFatBinary = dlsym(shared_lib, "cuModuleLoadFatBinary");
    real_cuLaunchKernelEx     = dlsym(shared_lib, "cuLaunchKernelEx");
    real_cuStreamSynchronize  = dlsym(shared_lib, "cuStreamSynchronize");
    init_unmodified(); // init unmodified functions 
    CHECK_DL(); // checking if any dl error presented
    // initialzie the L2 Flush Memory if benchmark is enabled
    if (NEUTRINO_BENCHMARK) {
        fprintf(log, "[benchmark] ENABLED L2 Flush Size %d\n", NEUTRINO_BENCHMARK_FLUSH_MEM_SIZE);
        real_cuMemAlloc_v2(&benchmark_flush_mem, NEUTRINO_BENCHMARK_FLUSH_MEM_SIZE);
    }
    clock_gettime(CLOCK_REALTIME, &start);
    free(LOG_PATH);
    free(TRACE_DIR);
    fprintf(log, "[info] init success\n"); 
}

/**
 * Module Management: cuModuleXXX
 * @see https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__MODULE.html
 * 
 * aims at saving the code of CUfunction to file system
 */

CUresult cuModuleLoadData(CUmodule* module, const void* image) {
    if (shared_lib == NULL)
        init();
        
    // first parse the image
    int magic, code_type;
    size_t size;
    const void *code;
    void *managed_bin;
    memcpy(&magic, image, sizeof(int));
    code_type = check_magic(magic);
    if (code_type == WRAPPED_FATBIN) { // shall be mapped to real image
        fatBinaryWrapper wrapper;
        memcpy(&wrapper, image, sizeof(wrapper));
        fatBinaryHeader header;
        memcpy(&header, wrapper.data, sizeof(header));
        size = get_fatbin_size(&header);
        code = (const void*) wrapper.data;
        magic = *(int*) wrapper.data;
    } else if (code_type == FATBIN) {
        fatBinaryHeader header;
        memcpy(&header, image, sizeof(header));
        size = get_fatbin_size(&header);
        code = (const void*) image;
    } else if (code_type == CUBIN) {
        Elf64_Ehdr header;
        memcpy(&header, image, sizeof(header));
        size = get_elf_size(&header);
        code = (const void*) image;
    } else if (code_type == ERROR_TYPE) {
        // check whether it's text file of NULL-Terminated PTX File
        // ptx must start with '//' and end with '\0' :)
        const char* ptx = (const char*) image;
        if (ptx[0] == '/' && ptx[1] == '/') {
            size = strlen(ptx); // naturally count till '\0'
            code = (const void*) image;
            code_type = PTX;
        } else { // still unrecognize, report the bug and terminates
            fprintf(log, "[mod] cuModuleLoadData unrecognize %d\n", magic);
        }
    }
    // copy the image to a new managed and protected place
    managed_bin = malloc(size);
    memcpy(managed_bin, code, size);

    // call the real function
    CUresult result = real_cuModuleLoadData(module, image);

    fprintf(log, "[mod] cuModuleLoadData %d module %p image %p type %s, size %zu\n", result, *module, image, code_types[code_type], size);

    // update to hashmap
    binmap_set(*module, managed_bin, size, NULL); // name = NULL as we don't know it now

    return result;
}

CUresult cuModuleLoadDataEx(CUmodule* module, const void* image, unsigned int numOptions, CUjit_option* options, void** optionValues) {
    if (shared_lib == NULL)
        init();

    // first parse the image
    int magic, code_type;
    size_t size;
    const void *code;
    void *managed_bin;
    memcpy(&magic, image, sizeof(int));
    code_type = check_magic(magic);
    if (code_type == WRAPPED_FATBIN) { // shall be mapped to real image
        fatBinaryWrapper wrapper;
        memcpy(&wrapper, image, sizeof(wrapper));
        fatBinaryHeader header;
        memcpy(&header, wrapper.data, sizeof(header));
        size = get_fatbin_size(&header);
        code = (const void*) wrapper.data;
        magic = *(int*) wrapper.data;
    } else if (code_type == FATBIN) {
        fatBinaryHeader header;
        memcpy(&header, image, sizeof(header));
        size = get_fatbin_size(&header);
        code = (const void*) image;
    } else if (code_type == CUBIN) {
        Elf64_Ehdr header;
        memcpy(&header, image, sizeof(header));
        size = get_elf_size(&header);
        code = (const void*) image;
    } else if (code_type == ERROR_TYPE) {
        // check whether it's text file of NULL-Terminated PTX File
        // ptx must start with '//' and end with '\0' :)
        const char* ptx = (const char*) image;
        if (ptx[0] == '/' && ptx[1] == '/') {
            size = strlen(ptx); // naturally count till '\0'
            code = (const void*) image;
            code_type = PTX;
        } else { // still unrecognize, report the bug and terminates
            fprintf(log, "[mod] cuModuleLoadDataEx unrecognize %d\n", magic);
        }
    }
    // copy the image to a new managed and protected place
    managed_bin = malloc(size);
    memcpy(managed_bin, code, size);
    
    CUresult (*real)(CUmodule*, const void*, unsigned int, CUjit_option*, void**) = dlsym(shared_lib, "cuModuleLoadDataEx");
    CHECK_DL(); // checking if any dl error presented
    CUresult ret = real(module, image, numOptions, options, optionValues);
    
    fprintf(log, "[mod] cuModuleLoadDataEx mod %p code %p type %s size %zu\n", *module, image, code_types[code_type], size);

    // update to hashmap
    binmap_set(*module, managed_bin, size, NULL); // name = NULL as we don't know it now

    return ret;
}

// @todo handle the multiple function with different name problem
CUresult cuModuleGetFunction(CUfunction* hfunc, CUmodule hmod, const char* name) {
    if (shared_lib == NULL)
        init();

    // first update the name
    size_t len = strlen(name);
    char* managed_name = malloc(len);
    memcpy(managed_name, name, len);
    
    // call real function
    CUresult result = real_cuModuleGetFunction(hfunc, hmod, name);

    fprintf(log, "[mod] cuModuleGetFunction func %p mod %p name %s\n", *hfunc, hmod, name);

    // then update the key from module to function
    int hash_ret = binmap_update_name_key(hmod, *hfunc, managed_name);
    if (hash_ret == -1)
        fprintf(log, "[hash] cuModuleGetFunction failed-update %p %p %s\n", hmod, *hfunc, managed_name);
    
    return result;
}

CUresult cuKernelGetFunction(CUfunction* pFunc, CUkernel kernel) {
    if (shared_lib == NULL)
        init();

    CUresult (*real)(CUfunction*, CUkernel) = dlsym(shared_lib, "cuKernelGetFunction");
    CHECK_DL(); // checking if any dl error presented
    CUresult result = real(pFunc, kernel);

    fprintf(log, "[mod] cuKernelGetFunction %p %p\n", *pFunc, kernel);

    // then update the key from kernel to function
    int hash_ret = binmap_update_key(kernel, *pFunc);
    if (hash_ret == -1) 
        fprintf(log, "[hash] cuKernelGetFunction failed-update %p %p\n", kernel, *pFunc);
    
    return result;
}

CUresult cuLibraryGetKernel(CUkernel* pKernel, CUlibrary library, const char* name) {
    if (shared_lib == NULL)
        init();

    // first update the name
    size_t len = strlen(name);
    char* managed_name = malloc(len);
    memcpy(managed_name, name, len);

    CUresult (*real)(CUkernel*, CUlibrary, const char*) = dlsym(shared_lib, "cuLibraryGetKernel");
    CHECK_DL(); // checking if any dl error presented
    CUresult result = real(pKernel, library, name);

    fprintf(log, "[mod] cuLibraryGetKernel kernel %p lib %p name %s\n", *pKernel, library, name);

    // then update the key from library to kernel
    int hash_ret = binmap_update_name_key(library, *pKernel, managed_name);
    if (hash_ret == -1) 
        fprintf(log, "[hash] cuLibraryGetKernel failed-update %p %p %s\n", library, *pKernel, managed_name);

    return result;
}


CUresult cuLibraryGetModule(CUmodule* pMod, CUlibrary library) {
    if (shared_lib == NULL)
        init();

    CUresult (*real)(CUmodule*, CUlibrary) = dlsym(shared_lib, "cuLibraryGetModule");
    CHECK_DL(); // checking if any dl error presented
    CUresult result = real(pMod, library);

    fprintf(log, "[mod] cuLibraryGetModule %d mod %p lib %p\n", result, *pMod, library);

    // then update the key from library to kernel
    int hash_ret = binmap_update_key(library, *pMod);
    if (hash_ret == -1)
        fprintf(log, "[hash] cuLibraryGetModule failed-update %p %p\n", library, *pMod);
    
    return result;
}

CUresult cuLibraryLoadData(CUlibrary* library, const void* code, CUjit_option* jitOptions, void** jitOptionsValues, unsigned int numJitOptions, CUlibraryOption* libraryOptions, void** libraryOptionValues, unsigned int numLibraryOptions) {
    if (shared_lib == NULL)
        init();

    // first parse the image
    int magic, bin_type;
    size_t size;
    const void *bin;
    void *managed_bin;
    memcpy(&magic, code, sizeof(int));
    bin_type = check_magic(magic);
    if (bin_type == WRAPPED_FATBIN) { // shall be mapped to real image
        fatBinaryWrapper wrapper;
        memcpy(&wrapper, code, sizeof(wrapper));
        fatBinaryHeader header;
        memcpy(&header, wrapper.data, sizeof(header));
        size = get_fatbin_size(&header);
        bin = (const void*) wrapper.data;
        magic = *(int*) wrapper.data;
    } else if (bin_type == FATBIN) {
        fatBinaryHeader header;
        memcpy(&header, code, sizeof(header));
        size = get_fatbin_size(&header);
        bin = (const void*) code;
    } else if (bin_type == CUBIN) {
        Elf64_Ehdr header;
        memcpy(&header, code, sizeof(header));
        size = get_elf_size(&header);
        bin = (const void*) code;
    } else if (bin_type == ERROR_TYPE) {
        // check whether it's NULL-Terminated PTX File
        // ptx must start with '//' and end with '\0' :)
        const char* ptx = (const char*) code;
        if (ptx[0] == '/' && ptx[1] == '/') {
            size = strlen(ptx); // naturally count till '\0'
            bin = (const void*) code;
            bin_type = PTX;
        } else { // still unrecognize, wait for 
            fprintf(log, "[Mod] cuLibraryLoadData unrecognize %d\n", magic);
        }
    }

    // copy the image to a new managed place -> won't be free by client
    managed_bin = malloc(size);
    memcpy(managed_bin, bin, size);

    CUresult (*real)(CUlibrary*, const void*, CUjit_option*, void**, unsigned int, CUlibraryOption*, void**, unsigned int) = dlsym(shared_lib, "cuLibraryLoadData");
    CHECK_DL(); // checking if any dl error presented
    CUresult result = real(library, code, jitOptions, jitOptionsValues, numJitOptions, libraryOptions, libraryOptionValues, numLibraryOptions);
    fprintf(log, "[mod] cuLibraryLoadData %d lib %p code %p type %s size %zu\n", result, *library, code, code_types[bin_type], size);

    // update to hashmap
    binmap_set(*library, managed_bin, size, NULL); // name = NULL as we don't know it now

    return result;
}

/**
 * Execution Control, cuLaunchXXX and cuFuncXXX
 * @see https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__EXEC.html
 * 
 * aims at providing runtime probing support
 */

CUresult cuLaunchKernel(CUfunction f, unsigned int gridDimX, unsigned int gridDimY, unsigned int gridDimZ, unsigned int blockDimX, unsigned int blockDimY, unsigned int blockDimZ, unsigned int sharedMemBytes, CUstream hStream, void** kernelParams, void** extra) {
    if (real_cuLaunchKernel == NULL)
        init();

    CUevent start_event, end_event;
    CUDA_CHECK(real_cuEventCreate(&start_event, CU_EVENT_DEFAULT));
    CUDA_CHECK(real_cuEventCreate(&end_event,   CU_EVENT_DEFAULT));
    
    CUDA_CHECK(real_cuEventRecord(start_event, hStream)); // use the stream specified in param

    float prologue_time, kernel_time, epilogue_time;
    CUresult result;
    CUfunction probed, pruned;
    char* kernel_name;
    int n_param, n_probe; 
    int* probe_sizes; // size of probes
    int* probe_types; // type of probes
    bool succeed; // jit status

    // try obtain the kernel compiled or raise compilation process 
    // @note count and record is only valid if succeed == true
    if (funcmap_get(f, &kernel_name, &n_param, &n_probe, &probe_sizes, &probe_types, &succeed, &probed, &pruned) == -1) {
        fprintf(log, "[exec] funcmap-not-find %p\n", f);
        fflush(log); // we need many fflush to avoid trace not printed
        // here try to get binary from binmap and start JIT compile
        size_t size;
        void* bin;
        if (binmap_get(f, &size, &kernel_name, &bin) == -1) { // not found the binary, fall back
            fprintf(log, "[jit] can't-find %p\n", f);
            fflush(log);
            funcmap_set(f,kernel_name, 0, 0, NULL, NULL, false, NULL, NULL); // set dummy with status FALSE
            goto backup;
        } else {
            fprintf(log, "[jit] find %p name %s bin %p size %zu\n", f, kernel_name, bin, size);
            fflush(log);
            // create a directory under the kernel directory with kernel_name
            // @note Linux has limit on directory length 255, replace it to sh1 so 20 char
            // @bugfix PyTorch kernel name usually is extremely long :(
            // @bugfix Triton autotune leads to a set of kernel with same name -> use counter to differentiate
            char *tmp = sha1(kernel_name);
            char *folder_name = (char*) malloc(5 + strlen(tmp));
            sprintf(folder_name, "%d_%s", kernel_idx, tmp);
            free(tmp);
            kernel_idx++;
            fprintf(log, "[jit] rename %s %s\n", kernel_name, folder_name);
            fflush(log);
            char* dir = malloc(strlen(KERNEL_DIR) + strlen(folder_name) + 10);
            sprintf(dir, "%s/%s", KERNEL_DIR, folder_name);
            if (mkdir(dir, 0755) == 0) { 
                fprintf(log, "[jit] mkdir %s\n", dir);
            } else {
                fprintf(log, "[jit] can't-mkdir %s\n", dir);
                    funcmap_set(f,kernel_name, 0, 0, NULL, NULL, false, NULL, NULL); // set dummy with status FALSE
                goto backup;
            }
            // create original.bin and write the binary to it
            char* path = malloc(strlen(dir) + 15);
            sprintf(path, "%s/original.bin", dir);
            FILE* original_bin = fopen(path, "wb");
            if (original_bin == NULL) {
                fprintf(log, "[jit] can't-open %s\n", path);
                    funcmap_set(f,kernel_name, 0, 0, NULL, NULL, false, NULL, NULL); // set dummy with status FALSE
                goto backup;
            }
            fwrite(bin, size, 1, original_bin);
            fclose(original_bin);
            fprintf(log, "[jit] write %s\n", path);
            // create subprocess to run process.py, be aware of multi-processing
            pid_t pid = fork();
            if (pid < 0) {
                fprintf(log, "[jit] can't-folk\n");
                funcmap_set(f,kernel_name, 0, 0, NULL, NULL, false, NULL, NULL); // set dummy with status FALSE
                goto backup;
            } else if (pid == 0) { // child process, run python process.py kernel name
                // python process.py <work_dir> <kernel_name>
                execlp(NEUTRINO_PYTHON, NEUTRINO_PYTHON, NEUTRINO_PROCESS_PY, dir, kernel_name, NULL);
                exit(EXIT_FAILURE); // reach here only if exec error -> failure
            } else { // parent process, wait for child
                fprintf(log, "[jit] subproc %s %s %s %s\n", NEUTRINO_PYTHON, NEUTRINO_PROCESS_PY, dir, kernel_name);
                int status;
                waitpid(pid, &status, 0);
                if (status != EXIT_SUCCESS) { 
                    fprintf(log, "[jit] python failed\n");
                    funcmap_set(f,kernel_name, 0, 0, NULL, NULL, false, NULL, NULL); // set dummy with status FALSE
                    goto backup; 
                } else {
                    fprintf(log, "[jit] python succeed\n");
                }
            }
            // read the kernel.info from file system
            sprintf(path, "%s/kernel.info", dir);
            char* kernel_info = readf(path, "r");
            // poor parser for kernel.info
            // @todo add checking alignment
            char* kernel_end = strchr(kernel_info, '\n');
            *kernel_end = '\0';
            kernel_name = kernel_info;
            char* start = kernel_end + 1;
            sscanf(start, " %d\n%d\n", &n_param, &n_probe);
            // read sizes and types of probe 
            probe_sizes = malloc(n_probe * sizeof(int));
            probe_types = malloc(n_probe * sizeof(int));
            char* strptr = strchr(strchr(start, '\n') + 1, '\n') + 1;
            for (int idx = 0; idx < n_probe; idx++) {
                sscanf(strptr, "%d,%d\n", &probe_types[idx], &probe_sizes[idx]);
                strptr = strchr(start, '\n') + 1;
            }
            // here read the 
            fprintf(log, "[jit] read %s name %s n_param %d n_probe %d\n", path, kernel_name, n_param, n_probe);
            // load probed.bin -> for collecting runtime info
            sprintf(path, "%s/probed.bin", dir);
            void* probed_bin = readf(path, "rb");
            // load pruned.bin -> for benchmark
            sprintf(path, "%s/pruned.bin", dir);
            void* pruned_bin = readf(path, "rb");
            // then load the binary to module
            CUmodule probed_mod, pruned_mod;
            CUDA_CHECK(real_cuModuleLoadData(&probed_mod,  probed_bin));
            // then get function with the SAME name -> we distinguish via 
            CUDA_CHECK(real_cuModuleGetFunction(&probed, probed_mod, kernel_name));
            CUDA_CHECK(real_cuModuleLoadData(&pruned_mod,  pruned_bin));
            // then get function with the SAME name -> we distinguish via 
            CUDA_CHECK(real_cuModuleGetFunction(&pruned, pruned_mod, kernel_name));
            // add record to hashmap to avoid re-compile 
            funcmap_set(f, kernel_name, n_param, n_probe, probe_sizes, probe_types, true, probed, pruned);
            fprintf(log, "[jit] finish %p name %s n_param %d\n", f, kernel_name, n_param);
            fflush(log);
            // free memory before we leave
            free(dir);
            free(path);
            free(kernel_info);
            free(probed_bin);
            free(pruned_bin);
            free(folder_name);
            // don't free(probe_sizes) -> used by func-map!!!
            succeed = true;
        }
    }
    // expose the original param
    fprintf(log, "[exec] funcmap-find %p %s\n", f, succeed ? "success" : "fail");
    // check the jit status, if failed, goto backup
    if (!succeed) { goto backup; }

    // @bugfix add timestamp to match with readings from high-level integration (PyTorch)
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    long long time = ts.tv_nsec + ts.tv_sec * 1e9;
    fprintf(log, "[exec] %lld param ", time);
    for (int i = 0; i < n_param; i++) {
        // @note print raw value -> help check raw number but mostly pointers...
        fprintf(log, "%llx ", *(CUdeviceptr*)kernelParams[i]);
    } 
    fprintf(log, "\n");
    fprintf(log, "[exec] grid %u %u %u block %u %u %u shared %u\n", gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ, sharedMemBytes);
    fflush(log);

    // here start to calculate memory size for every probe based on grid, block and probe_sizes
    // formula similar to ndarray based on grid, block / warp
    const size_t gridSize = gridDimX * gridDimY * gridDimZ;   
    const size_t blockSize = blockDimX * blockDimY * blockDimZ;
    const size_t warpSize = CDIV(blockSize, WARP_SIZE);
    size_t *probe_real_sizes = malloc(n_probe * sizeof(size_t));
    size_t total_probe_sizes = 0;
    for (int idx = 0; idx < n_probe; idx++) {
        if (probe_types[idx] == PROBE_TYPE_THREAD) {
            probe_real_sizes[idx] = gridSize * blockSize * probe_sizes[idx];
            fprintf(log, "[exec] grid %zu block %zu probe %d total %zu\n", gridSize, blockSize, probe_sizes[idx], probe_real_sizes[idx]);
        } else if (probe_types[idx] == PROBE_TYPE_WARP) {
            probe_real_sizes[idx] = gridSize * warpSize * probe_sizes[idx];
            fprintf(log, "[exec] grid %zu warp  %zu probe %d total %zu\n", gridSize, warpSize, probe_sizes[idx], probe_real_sizes[idx]);
        }
        total_probe_sizes += probe_real_sizes[idx];
    }

    fprintf(log, "[exec] probe-mem %zu (bytes)\n", total_probe_sizes);
    
    // Allocate Memory on Host and Device
    void** h_probe_mems = malloc(n_probe * sizeof(void*));
    CUdeviceptr* d_probe_mems = malloc(n_probe * sizeof(CUdeviceptr));
    for (int idx = 0; idx < n_probe; idx++) {
        h_probe_mems[idx] = malloc(probe_real_sizes[idx]);
        CUDA_CHECK(real_cuMemAlloc_v2(&d_probe_mems[idx], probe_real_sizes[idx]));
        CUDA_CHECK(real_cuMemsetD32_v2(d_probe_mems[idx], 0, probe_real_sizes[idx] / 4UL));
    }
    
    // @note argument layout is (n_param + n_probe) * sizeof(void*), n_param is parsed inside ptx
    void** probe_args = malloc((n_param + n_probe) * sizeof(void*));
    memcpy(probe_args, kernelParams, n_param * sizeof(void*)); // copy the raw parameters
    for (int idx = 0; idx < n_probe; idx++) { 
        probe_args[n_param + idx] = &d_probe_mems[idx]; // offset with n_param -> place later
    }
    /**
     * @note set the shared memory size. If the kernel shared memory size exceed a limit (usually half) 
     * of the physical SMEM size (per SM), then cuLaunchKernel will raise CUDA_ERROR_INVALID_VALUE, we
     * need to manually set via cuFuncSetAttribute(kernel, CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES, shared)
     * 
     * @details Neutrino JIT Function is considered a new one and can not inherit original setup...
     */
    CUDA_CHECK(real_cuFuncSetAttribute(probed, CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES, sharedMemBytes));
    if (NEUTRINO_BENCHMARK) {
        real_cuMemsetD32_v2(benchmark_flush_mem,0, NEUTRINO_BENCHMARK_FLUSH_MEM_SIZE / 4UL);
    }
    CUDA_CHECK(real_cuEventRecord(end_event, hStream)); // use the stream specified in param
    CUDA_CHECK(real_cuEventSynchronize(end_event));
    CUDA_CHECK(real_cuEventElapsedTime(&prologue_time, start_event, end_event));
    CUDA_CHECK(real_cuEventRecord(start_event, hStream)); // use the stream specified in param
    // launch kernel by call real_cuLaunchKernel function
    result = real_cuLaunchKernel(probed, gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, 
                                    blockDimZ, sharedMemBytes, hStream, probe_args, extra);
    CUDA_CHECK(real_cuEventRecord(end_event, hStream)); // use the stream specified in param
    CUDA_CHECK(real_cuEventSynchronize(end_event));
    // calculate the real kernel time
    CUDA_CHECK(real_cuEventElapsedTime(&kernel_time, start_event, end_event));
    CUDA_CHECK(real_cuEventRecord(start_event, hStream)); // use the stream specified in param
    if (result != CUDA_SUCCESS) {
        for (int idx = 0; idx < n_probe; idx++) {
            free(h_probe_mems[idx]);
            CUDA_CHECK(real_cuMemFree_v2(d_probe_mems[idx]));
        }
        free(h_probe_mems);
        free(d_probe_mems);
        free(probe_real_sizes);
        free(probe_args);
        fprintf(log, "[exec] failed %d\n", result);
        goto backup;
    } else {
        fprintf(log, "[exec] succeed %d\n", result);
    }

    // dump to disk
    for (int idx = 0; idx < n_probe; idx++) {
        CUDA_CHECK(real_cuMemcpyDtoH_v2(h_probe_mems[idx], d_probe_mems[idx], probe_real_sizes[idx]));
    }
    // create dump file
    char* DUMP_FILE_NAME = malloc(strlen(RESULT_DIR) + 20);
    struct timespec end;
    clock_gettime(CLOCK_REALTIME, &end);
    double elapsed = ((end.tv_sec * 1e9 + end.tv_nsec) - (start.tv_sec * 1e9 + start.tv_nsec)) / 1e9;
    sprintf(DUMP_FILE_NAME, "%s/%.6f.bin", RESULT_DIR, elapsed);
    FILE *fp = fopen(DUMP_FILE_NAME, "wb");
    if (!fp) { 
        fprintf(log, "[exec] can't-save %s\n", DUMP_FILE_NAME); 
        return CUDA_SUCCESS; 
    }
    // write header to file
    trace_header_t header;
    // gridDim: uint3
    header.gridDimX = gridDimX;
    header.gridDimY = gridDimY;
    header.gridDimZ = gridDimZ;
    // blockDim: uint3
    header.blockDimX = blockDimX;
    header.blockDimY = blockDimY;
    header.blockDimZ = blockDimZ;
    // sharedMemBytes and numProbes
    header.sharedMemBytes = sharedMemBytes;
    header.numProbes = n_probe;
    fwrite(&header, sizeof(header), 1, fp);
    // write sections to file
    size_t offset = sizeof(header) + n_probe * sizeof(trace_section_t);
    for (int idx = 0; idx < n_probe; idx++) {
        trace_section_t section;
        section.size = probe_real_sizes[idx];
        section.offset = offset;
        offset += section.size;
        fwrite(&section, sizeof(section), 1, fp);
    }
    // write data
    for (int idx = 0; idx < n_probe; idx++) {
        fwrite(h_probe_mems[idx], 1, probe_real_sizes[idx], fp);
    }
    // close file
    fclose(fp);
    fprintf(log, "[exec] save %s size %zu\n", DUMP_FILE_NAME, offset);
    // free allocated memory before leave
    for (int idx = 0; idx < n_probe; idx++) {
        free(h_probe_mems[idx]);
        CUDA_CHECK(real_cuMemFree_v2(d_probe_mems[idx]));
    }
    free(h_probe_mems);
    free(d_probe_mems);
    free(probe_real_sizes);
    free(probe_args);
    
    // on leave
    CUDA_CHECK(real_cuEventRecord(end_event, hStream)); // use the stream specified in param
    CUDA_CHECK(real_cuEventSynchronize(end_event));
    CUDA_CHECK(real_cuEventElapsedTime(&epilogue_time, start_event, end_event));
    if (NEUTRINO_BENCHMARK)  {
        real_cuMemsetD32_v2(benchmark_flush_mem,0, NEUTRINO_BENCHMARK_FLUSH_MEM_SIZE / 4UL);
        // here Neutrino use pruned ptx being compiled with exactly the same configuration (assmbler & optimization) with probed
        float original_time;
        CUDA_CHECK(real_cuFuncSetAttribute(pruned, CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES, sharedMemBytes));
        CUDA_CHECK(real_cuEventRecord(start_event, hStream)); // use the stream specified in param
        // launch original kernel with original parameter
        result = real_cuLaunchKernel(pruned, gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ, sharedMemBytes, hStream, kernelParams, extra);
        CUDA_CHECK(real_cuEventRecord(end_event, hStream)); // use the stream specified in param
        CUDA_CHECK(real_cuEventSynchronize(end_event));
        // calculate the real kernel time
        CUDA_CHECK(real_cuEventElapsedTime(&original_time, start_event, end_event));
        fprintf(log, "[benchmark] prologue %f kernel %f epilogue %f original %f impact %f %d\n", prologue_time, kernel_time, epilogue_time, original_time, kernel_time / original_time, result);
    } else {
        fprintf(log, "[exec] prologue %f kernel %f epilogue %f ratio %f\n", prologue_time, kernel_time, epilogue_time, (prologue_time + kernel_time + epilogue_time) / kernel_time);
    }
    
    return CUDA_SUCCESS; // reach here must be CUDA_SUCCESS

backup:
    fprintf(log, "[exec] backup %u %u %u block %u %u %u shared %u\n", gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ, sharedMemBytes);
    // fall back to original version
    result = real_cuLaunchKernel(f, gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ, sharedMemBytes, hStream, kernelParams, extra);
    return result;
}

/**
 * Other Modified Modules for Neutrino
 */

// Memory API
CUresult cuMemAlloc_v2(CUdeviceptr *dptr, size_t bytesize) {
    if (real_cuMemAlloc_v2 == NULL)
        init();

    CUresult result = real_cuMemAlloc_v2(dptr, bytesize);

    fprintf(log, "[mem] cuMemAlloc_v2 %d dptr %llx bytesize %zu\n", result, *dptr, bytesize);

    return result;
}

CUresult cuMemAllocHost_v2(void** pp, size_t bytesize) {
    if (real_cuMemAllocHost_v2 == NULL)
        init();
    
    CUresult retval = real_cuMemAllocHost_v2(pp, bytesize); // call the symbol

    fprintf(log, "[mem] cuMemAllocHost_v2 %d ptr %p bytesize %zu\n", retval, *pp, bytesize);
    
    return retval;
}

CUresult cuMemFree_v2(CUdeviceptr dptr) {
    if (real_cuMemFree_v2 == NULL)
        init();

    CUresult result = real_cuMemFree_v2(dptr);

    fprintf(log, "[mem] cuMemFree_v2 %d dptr %llx\n", result, dptr);
    
    return result;
}

// an example of 
CUresult cuMemcpy_v2(CUdeviceptr dst, CUdeviceptr src, size_t ByteCount) {
    if (shared_lib == NULL)
        init();

    CUresult (*real)(CUdeviceptr, CUdeviceptr, size_t) = dlsym(shared_lib, "cuMemcpy_v2");
    CHECK_DL();

    CUresult result = real(dst, src, ByteCount);

    fprintf(log, "[mem] cuMemcpy_v2 %d dst %llx src %llx ByteCount %zu\n", result, dst, src, ByteCount); // unexpected func call

    return result;
}

CUresult cuMemcpyHtoD_v2(CUdeviceptr dstDevice, const void* srcHost, size_t ByteCount) {
    if (real_cuMemcpyHtoD_v2 == NULL)
        init();

    CUresult result = real_cuMemcpyHtoD_v2(dstDevice, srcHost, ByteCount);

    fprintf(log, "[mem] cuMemcpyHtoD_v2 %d dstDevice %llx srcHost %p ByteCount %zu\n", result, dstDevice, srcHost, ByteCount);

    return result;
}

CUresult cuMemcpyDtoH_v2(void* dstHost, CUdeviceptr srcDevice, size_t ByteCount) {
    if (real_cuMemcpyDtoH_v2 == NULL)
        init();

    CUresult result = real_cuMemcpyDtoH_v2(dstHost, srcDevice, ByteCount);
    
    fprintf(log, "[mem] cuMemcpyDtoH_v2 %d dstHost %p srcDevice %llx ByteCount %zu\n", result, dstHost, srcDevice, ByteCount);

    return result;
}

CUresult cuMemsetD32_v2(CUdeviceptr dstDevice, unsigned int ui, size_t N) {
    if (real_cuMemsetD32_v2 == NULL)
        init();
        
    CUresult result = real_cuMemsetD32_v2(dstDevice, ui, N);

    fprintf(log, "[mem] cuMemsetD32_v2 %d dstDevice %llx ui %u N %zu\n", result, dstDevice, ui, N);

    return result;
}

CUresult cuDeviceGetAttribute(int* pi, CUdevice_attribute attrib, CUdevice dev) {
    if (real_cuDeviceGetAttribute == NULL)
        init();
    
    CUresult result = real_cuDeviceGetAttribute(pi, attrib, dev);
    if (VERBOSE)
        fprintf(log, "[info] cuDeviceGetAttribute %d attrib %d pi %d dev %d\n", result, attrib, *pi, dev); // unexpected func call
    
    return result;
}

/**
 * This API is INTENTIONALLY UNDOCUMENTED BY NVIDIA 
 * to facilitate their usage of dark apis such as cuBLAS
 */
CUresult cuGetExportTable(const void** ppExportTable, const CUuuid* pExportTableId) {
    if (shared_lib == NULL)
        init();
    
    CUresult (*real)(const void**, const CUuuid*) = dlsym(shared_lib, "cuGetExportTable");
    CHECK_DL(); 

    CUresult result = real(ppExportTable, pExportTableId);
    fprintf(log, "[info] cuGetExportTable %d %p 0x%lx 0x%lx\n", result, *ppExportTable, (uint64_t)pExportTableId->bytes[0], (uint64_t)pExportTableId->bytes[8]); // unexpected func call

    return result;
}

CUresult cuModuleLoad(CUmodule* module, const char* fname) {
    if (real_cuModuleLoad == NULL)
        init();
    
    CUresult retval = real_cuModuleLoad(module, fname); // call the symbol

    fprintf(log, "[info] cuModuleLoad %d\n", retval);
    
    return retval;
}

CUresult cuModuleLoadFatBinary(CUmodule* module, const void* fatCubin) {
    if (real_cuModuleLoadFatBinary == NULL)
        init();
    
    CUresult retval = real_cuModuleLoadFatBinary(module, fatCubin); // call the symbol

    fprintf(log, "[info] cuModuleLoadFatBinary %d\n", retval);
    
    return retval;
}

CUresult cuStreamSynchronize(CUstream hStream) {
    if (real_cuStreamSynchronize == NULL)
        init();
    
    CUresult retval = real_cuStreamSynchronize(hStream); // call the symbol

    fprintf(log, "[info] cuStreamSynchronize %d\n", retval);
    
    return retval;
}


/**
 * Unmodified part of code, automatically generated by parse.py
 * usually we don't trace these API, just print a log to indicate they're used
 * if there's any weird behavior caused by Neutrino (unlikely), we can have a look
 */
#include "unmodified.c" // include the auto-generated code

/**
 * @note this function is intentially masked out by Neutrino because it might
 *       let process jump out of Neutrino's Hook Driver directly to real driver
 */
/*
CUresult cuGetProcAddress_v2(const char* symbol, void** pfn, int cudaVersion, cuuint64_t flags, CUdriverProcAddressQueryResult* symbolStatus) {
    if (real_cuGetProcAddress_v2 == NULL)
        init();
    
    CUresult ret;

    if (strcmp(symbol, "cuGetProcAddress") == 0) {
        CUresult (*cuGetProcAddress_v2_ptr)(const char* symbol, void** pfn, int cudaVersion, cuuint64_t flags, CUdriverProcAddressQueryResult* symbolStatus) = cuGetProcAddress_v2;
        *pfn = cuGetProcAddress_v2_ptr;
        ret = CUDA_SUCCESS;
        fprintf(log, "[pass] cuGetProcAddress_v2 %d %s %d return-myself\n", ret, symbol, cudaVersion); // unexpected func call
    } else if (strcmp(symbol, "cuGetExportTable") == 0) {
        // CUresult (*cuGetExportTable_ptr)(const void**, const CUuuid*) = cuGetExportTable;
        // *pfn = cuGetExportTable_ptr;
        ret = CUDA_ERROR_INVALID_VALUE;
        fprintf(log, "[pass] cuGetProcAddress_v2 %d %s %d return-ours\n", ret, symbol, cudaVersion); // unexpected func call
    } else {
        ret = real_cuGetProcAddress_v2(symbol, pfn, cudaVersion, flags, symbolStatus);
        fprintf(log, "[pass] cuGetProcAddress_v2 %d %s %d\n", ret, symbol, cudaVersion); // unexpected func call
    }
   
    return ret;
}

// @note a fix for NCCL kernels -> don't support too much in config now
CUresult cuLaunchKernelEx(const CUlaunchConfig* config, CUfunction f, void** kernelParams, void** extra) {

    if (real_cuLaunchKernelEx == NULL)
        init();
    
    // try to read the environment variable and check for modification
    char* NEUTRINO_ENABLE_STR = getenv("NEUTRINO_ENABLE");
    if (NEUTRINO_ENABLE_STR != NULL) {
        if (atoi(NEUTRINO_ENABLE_STR) != NEUTRINO_ENABLE) {
            fprintf(log, "[exec] trace %s\n", atoi(NEUTRINO_ENABLE_STR) == 0 ? "disabled" : "enabled");
            NEUTRINO_ENABLE = atoi(NEUTRINO_ENABLE_STR);
        }
    }
    if (NEUTRINO_ENABLE == 0) {
        goto backup;
    }

    CUresult result;
    CUfunction count, record;
    char* kernel_name;
    int n_param;
    bool succeed; // jit status

    // make it compatible to our logging
    unsigned int gridDimX = config->gridDimX;
    unsigned int gridDimY = config->gridDimY;
    unsigned int gridDimZ = config->gridDimZ;
    unsigned int blockDimX = config->blockDimX; 
    unsigned int blockDimY = config->blockDimY; 
    unsigned int blockDimZ = config->blockDimZ;
    unsigned int sharedMemBytes = config->sharedMemBytes;

    // try obtain the kernel compiled or raise compilation process 
    // @note count and record is only valid if succeed == true
    if (funcmap_get(f, &count, &record, &kernel_name, &n_param, &succeed) == -1) { // fall back to compile
        fprintf(log, "[exec] funcmap-not-find %p\n", f);
        fflush(log);
        // get function from bin map
        size_t size;
        void* bin;
        if (binmap_get(f, &size, &kernel_name, &bin) == -1) { // not found the binary, fall back
            fprintf(log, "[jit] can't-find %p\n", f);
            fflush(log);
            funcmap_set(f, NULL, NULL, kernel_name, 0, false); // set a dummy item
            goto backup;
        } else {
            fprintf(log, "[jit] find %p name %s bin %p size %zu\n", f, kernel_name, bin, size);
            fflush(log);
            // create a directory under the kernel directory with kernel_name
            // @note Linux has limit on directory length 255, replace it to sh1
            // @bugfix PyTorch kernel name usually is extremely long :(
            // @bugfix Triton autotune leads to a set of kernel with same name -> use counter to differentiate
            char *tmp, *folder_name;
            tmp = sha1(kernel_name);
            folder_name = (char*) malloc(5 + strlen(tmp));
            sprintf(folder_name, "%d_%s", kernel_idx, tmp);
            free(tmp);
            kernel_idx++;
            fprintf(log, "[jit] rename %s %s\n", kernel_name, folder_name);
            fflush(log);
            char* dir = malloc(strlen(KERNEL_DIR) + strlen(folder_name) + 10);
            sprintf(dir, "%s/%s", KERNEL_DIR, folder_name);
            if (mkdir(dir, 0755) == 0) { 
                fprintf(log, "[jit] mkdir %s\n", dir);
            } else {
                fprintf(log, "[jit] can't-mkdir %s\n", dir);
                funcmap_set(f, NULL, NULL, kernel_name, 0, false); // set a dummy item
                goto backup;
            }
            // create original.bin and write the binary to it
            char* path = malloc(strlen(dir) + 15);
            sprintf(path, "%s/original.bin", dir);
            FILE* original_bin = fopen(path, "wb");
            if (original_bin == NULL) {
                fprintf(log, "[jit] can't-open %s\n", path);
                funcmap_set(f, NULL, NULL, kernel_name, 0, false); // set a dummy item
                goto backup;
            }
            fwrite(bin, size, 1, original_bin);
            fclose(original_bin);
            fprintf(log, "[jit] write %s\n", path);
            // create subprocess to run process.py, be aware of multi-processing
            pid_t pid = fork();
            if (pid < 0) {
                fprintf(log, "[jit] can't-folk\n");
                funcmap_set(f, NULL, NULL, kernel_name, 0, false); // set a dummy item
                goto backup;
            } else if (pid == 0) { // child process, run python process.py kernel name
                // python process.py <work_dir> <kernel_name>
                execlp(NEUTRINO_PYTHON, NEUTRINO_PYTHON, NEUTRINO_PROCESS_PY, dir, kernel_name, NULL);
                exit(EXIT_FAILURE); // reach here only if exec error -> failure
            } else { // parent process, wait for child
                fprintf(log, "[jit] subproc %s %s %s %s\n", NEUTRINO_PYTHON, NEUTRINO_PROCESS_PY, dir, kernel_name);
                int status;
                waitpid(pid, &status, 0);
                if (status != EXIT_SUCCESS) { 
                    fprintf(log, "[jit] python failed\n");
                    funcmap_set(f, NULL, NULL, kernel_name, 0, false); // set a dummy item
                    goto backup; 
                } else {
                    fprintf(log, "[jit] python succeed\n");
                }
            }
            // read the kernel.info from file system
            sprintf(path, "%s/kernel.info", dir);
            char* kernel_info = readf(path, "r");
            // parse n_param
            // @todo add checking alignment
            char* start = strchr(kernel_info, '\n');
            char* end = strchr(start, '\n'); // find the second \n
            *end = '\0'; // make it NULL-Terminated
            n_param = atoi(start + 1); // skip \n
            *start = '\0'; // make it NULL-Terminated
            kernel_name = kernel_info;
            fprintf(log, "[jit] read %s name %s n_param %d\n", path, kernel_name, n_param);
            // load count.bin and record.bin
            sprintf(path, "%s/count.bin", dir);
            void* count_bin = readf(path, "rb");
            sprintf(path, "%s/record.bin", dir);
            void* record_bin = readf(path, "rb");
            // then load the binary to module
            CUmodule count_mod, record_mod;
            CUDA_CHECK(real_cuModuleLoadData(&count_mod,  count_bin));
            CUDA_CHECK(real_cuModuleLoadData(&record_mod, record_bin));
            // then get function with the SAME name -> we distinguish via 
            CUDA_CHECK(real_cuModuleGetFunction(&count, count_mod, kernel_name));
            CUDA_CHECK(real_cuModuleGetFunction(&record, record_mod, kernel_name));
            // place into hashmap to avoid re-compile 
            funcmap_set(f, count, record, kernel_name, n_param, true);
            fprintf(log, "[jit] finish %p name %s n_param %d\n", f, kernel_name, n_param);
            fflush(log);
            // free memory before we leave
            free(dir);
            free(path);
            free(kernel_info);
            free(count_bin);
            free(record_bin);
            free(folder_name);
            succeed = true;
        }
    }
    // expose the original param
    fprintf(log, "[exec] funcmap-find %p %s\n", f, succeed ? "success" : "fail");
    // check the jit status, if failed, goto backup
    if (!succeed) { goto backup; }

    // @bugfix add timestamp to match with PyTorch Profiler or other Profiler
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    long long time = ts.tv_nsec + ts.tv_sec * 1e9;
    fprintf(log, "[exec] %lld param ", time);
    for (int i = 0; i < n_param; i++) {
        fprintf(log, "%llx ", *(CUdeviceptr*)kernelParams[i]);
    }
    // @bugfix: why Triton Matmul leads to 
    
    fprintf(log, "\n");
    fprintf(log, "[exec] grid %u %u %u block %u %u %u shared %u\n", gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ, sharedMemBytes);
    fflush(log);

    const size_t gridSize = gridDimX * gridDimY * gridDimZ;   
    const size_t blockSize = blockDimX * blockDimY * blockDimZ;
    const size_t size_AccessCounter = ALIGN_256(gridSize * sizeof(uint64_t));
    
    // COUNT MEMORY ACCESS
    uint64_t *h_AccessCounter = malloc(size_AccessCounter);
    CUdeviceptr d_AccessCounter;
    CUDA_CHECK(real_cuMemAlloc_v2(&d_AccessCounter, size_AccessCounter));
    CUDA_CHECK(real_cuMemsetD32_v2(d_AccessCounter, 0, size_AccessCounter / 4UL)); // := sizeof(uint64_t) 
    // argument layout is (n_param + 1) * sizeof(void*), n_param is parsed inside ptx
    void** count_args = malloc((n_param + 1) * sizeof(void*));
    memcpy(count_args, kernelParams, n_param * sizeof(void*)); // copy the raw parameters
    count_args[n_param] = &d_AccessCounter;
    result = real_cuLaunchKernelEx(config, count, count_args, extra);
    if (result != CUDA_SUCCESS) {
        const char *msg;                  
		real_cuGetErrorName(result, &msg);
        fprintf(log, "[exec] count-failed %d %s\n", result, msg);
        free(h_AccessCounter);
        free(count_args);
        CUDA_CHECK(real_cuMemFree_v2(d_AccessCounter));
        goto backup;
    } else {
        // fprintf(log, "[exec] count %d size %zu\n", result, size_AccessCounter);
    }
    fflush(log);
    result = real_cuMemcpyDtoH_v2(h_AccessCounter, d_AccessCounter, size_AccessCounter);
    if (result != CUDA_SUCCESS) {
        free(h_AccessCounter);
        free(count_args);
        // fprintf(log, "[exec] count-fail-copy %d size %zu\n", result, size_AccessCounter);
        fflush(stdout);
        CUDA_CHECK(real_cuMemFree_v2(d_AccessCounter));
        goto backup;
    }
    uint32_t maxAccessPerBlock = 0u;
    for (int idx = 0; idx < gridSize; idx++)
        maxAccessPerBlock = (maxAccessPerBlock > h_AccessCounter[idx]) ? maxAccessPerBlock : h_AccessCounter[idx];
    // free memories allocated before we leave
    free(h_AccessCounter);
    free(count_args);
    CUDA_CHECK(real_cuMemFree_v2(d_AccessCounter));

    // RECORD MEMORY ACCESS
    const size_t size_clock_record   = gridSize * maxAccessPerBlock * sizeof(uint64_t) * MARGIN_FACTOR;
    const size_t size_address_record = gridSize * maxAccessPerBlock * sizeof(uint64_t) * MARGIN_FACTOR;
    // fprintf(log, "[exec] maxAccessPerBlock %u alloc %zu (KB)\n", maxAccessPerBlock, (size_clock_record + size_address_record) / 1024);
    uint64_t *h_clock_record   = malloc(size_clock_record);
    uint64_t *h_address_record = malloc(size_address_record);
    CUdeviceptr d_clock_record, d_address_record;
    CUDA_CHECK(real_cuMemAlloc_v2(&d_clock_record,   size_clock_record));
    CUDA_CHECK(real_cuMemAlloc_v2(&d_address_record, size_address_record));
    CUDA_CHECK(real_cuMemsetD32_v2(d_clock_record, ~0, size_clock_record / 4UL)); // 4UL := 32bit
    // argument layout is (n_param + 3) * sizof(void*), n_param is parsed inside ptx
    void** record_args = malloc((n_param + 3) * sizeof(void*));
    memcpy(record_args, kernelParams, n_param * sizeof(void*));
    record_args[n_param]     = &d_clock_record;
    record_args[n_param + 1] = &d_address_record;
    record_args[n_param + 2] = &maxAccessPerBlock;
    result = real_cuLaunchKernelEx(config, record, record_args, extra);
    if (result != CUDA_SUCCESS) {
        free(h_clock_record);
        free(h_address_record);
        free(record_args);
        CUDA_CHECK(real_cuMemFree_v2(d_clock_record));
        CUDA_CHECK(real_cuMemFree_v2(d_address_record));
        fprintf(log, "[exec] record-failed %d\n", result);
        goto backup;
    } else {
        // fprintf(log, "[exec] record %d\n", result);
    }
    // copy and dump
    CUDA_CHECK(real_cuMemcpyDtoH_v2(h_clock_record,   d_clock_record,   size_clock_record));
    CUDA_CHECK(real_cuMemcpyDtoH_v2(h_address_record, d_address_record, size_address_record));
    // create dump file
    char* DUMP_FILE_NAME = malloc(strlen(MEMORY_DIR) + 20);
    struct timespec end;
    clock_gettime(CLOCK_REALTIME, &end);
    double elapsed = ((end.tv_sec * 1e9 + end.tv_nsec) - (start.tv_sec * 1e9 + start.tv_nsec)) / 1e9;
    sprintf(DUMP_FILE_NAME, "%s/%.6f.bin", MEMORY_DIR, elapsed);
    FILE *fp = fopen(DUMP_FILE_NAME, "wb");
    if (!fp) { 
        fprintf(log, "[exec] can't-save %s\n", DUMP_FILE_NAME); 
        return CUDA_SUCCESS; 
    }
    traceHeader header;
    // gridDim: uint3
    header.gridDimX = gridDimX;
    header.gridDimY = gridDimY;
    header.gridDimZ = gridDimZ;
    // blockDim: uint3
    header.blockDimX = blockDimX;
    header.blockDimY = blockDimY;
    header.blockDimZ = blockDimZ;
    // maxAccessPerBlock: unsigned long long
    header.maxAccessPerBlock = maxAccessPerBlock;
    // MARGIN_FACTOR
    header.margin_factor = MARGIN_FACTOR;
    // size
    header.size_clock = size_clock_record;
    header.size_addr  = size_address_record;
    // write header to file
    fwrite(&header, sizeof(header), 1, fp);
    // clockRecord
    fwrite(h_clock_record,   size_clock_record,   1, fp);
    fwrite(h_address_record, size_address_record, 1, fp);
    // close file
    fclose(fp);
    fprintf(log, "[exec] save %s size %zu\n", DUMP_FILE_NAME, 
        size_clock_record + size_address_record + sizeof(header));
    // free allocated memory before leave
    free(h_clock_record);
    free(h_address_record);
    free(record_args);
    free(DUMP_FILE_NAME);
    CUDA_CHECK(real_cuMemFree_v2(d_clock_record));
    CUDA_CHECK(real_cuMemFree_v2(d_address_record));
    return CUDA_SUCCESS;

backup:
    fprintf(log, "[exec] backup\n");
    // fall back to original version
    result = real_cuLaunchKernelEx(config, f, kernelParams, extra); // call the symbol
    return result;
}

*/
