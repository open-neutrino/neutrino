/**
 * Neutrino Hook Driver, AMD Implementation
 * 
 * @note experimental support only
 */

#include "common.h" // for common headers
#include <hip/hip_runtime.h> // for AMD HIP Hooked APIs

#define WARP_SIZE 64 // @bug some RDNA use 32 as WARP_SIZE

// used by benchmark mode
static hipDeviceptr_t benchmark_flush_mem = NULL;

// following functions are hooked for internal usage
hipError_t (*real_hipModuleLoadData)(hipModule_t*, const void*) = NULL;
hipError_t (*real_hipModuleLoadDataEx)(hipModule_t*, const void*, unsigned int, hipJitOption*, void**) = NULL;
hipError_t (*real_hipModuleGetFunction)(hipFunction_t*, hipModule_t, const char*) = NULL;
hipError_t (*real_hipModuleLaunchKernel)(hipFunction_t, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, hipStream_t, void**, void**) = NULL;
hipError_t (*real_hipMalloc)(void**, size_t) = NULL;
hipError_t (*real_hipFree)(void*) = NULL;
hipError_t (*real_hipModuleLoad)(hipModule_t*, const char*) = NULL;
// following are for weird parsing
hipError_t (*real_hipEventRecord)(hipEvent_t, hipStream_t) = NULL;
const char* (*real_hipGetErrorName)(hipError_t) = NULL;
const char* (*real_hipGetErrorString)(hipError_t) = NULL;
const char* (*real_hipApiName)(uint32_t) = NULL;
const char* (*real_hipKernelNameRef)(const hipFunction_t) = NULL;
const char* (*real_hipKernelNameRefByPtr)(const void*, hipStream_t) = NULL;

// include auto-generated signatures for unmodified functions
// @note signature.c will be auto generated by parse.py
#include "signature.c"

#define HIP_CHECK(cmd) do {                     \
    hipError_t result = cmd;                    \
    if (result != hipSuccess) {                 \
        const char *msg;                        \
        real_hipDrvGetErrorName(result, &msg);  \
        printf("Neutrino fail: %s:%d '%s'\n",   \
                __FILE__, __LINE__, msg);       \
        exit(EXIT_FAILURE);                     \
    }                                           \
} while (0)

static void init(void) {
    common_init(); // init common modules
    real_hipModuleLoadData      = dlsym(shared_lib, "hipModuleLoadData");
    real_hipModuleLoadDataEx    = dlsym(shared_lib, "hipModuleLoadDataEx");
    real_hipModuleGetFunction   = dlsym(shared_lib, "hipModuleGetFunction");
    real_hipModuleLaunchKernel  = dlsym(shared_lib, "hipModuleLaunchKernel");
    real_hipMalloc              = dlsym(shared_lib, "hipMalloc");
    real_hipFree                = dlsym(shared_lib, "hipFree");
    real_hipModuleLoad          = dlsym(shared_lib, "hipModuleLoad");
    real_hipEventRecord         = dlsym(shared_lib, "hipEventRecord");
    real_hipGetErrorName        = dlsym(shared_lib, "hipGetErrorName");
    real_hipGetErrorString      = dlsym(shared_lib, "hipGetErrorString");
    real_hipApiName             = dlsym(shared_lib, "hipApiName");
    real_hipKernelNameRef       = dlsym(shared_lib, "hipKernelNameRef");
    real_hipKernelNameRefByPtr  = dlsym(shared_lib, "hipKernelNameRefByPtr");
    init_unmodified(); // init unmodified functions, defined in signature.c
    CHECK_DL(); // checking if any dl error presented
    // initialzie the L2 Flush Memory if benchmark is enabled
    if (NEUTRINO_BENCHMARK) {
        fprintf(event_log, "[benchmark] ENABLED L2 Flush Size %d\n", NEUTRINO_BENCHMARK_FLUSH_MEM_SIZE);
        real_hipMalloc(&benchmark_flush_mem, NEUTRINO_BENCHMARK_FLUSH_MEM_SIZE);
    }
    fprintf(event_log, "[info] init success\n"); 
}

/**
 * Module Management
 * @see https://rocm.docs.amd.com/projects/HIP/en/latest/reference/hip_runtime_api/modules/module_management.html
 * 
 * HIP Module Management is simpler than CUDA, only Module -> Function
 */

hipError_t hipModuleLoadData(hipModule_t* module, const void* image) {
    if (shared_lib == NULL) { init(); }

    // first parse the image
    int magic, code_type;
    size_t size;
    const void *code;
    void *managed_bin;
    memcpy(&magic, image, sizeof(int));
    code_type = check_magic(magic);
    if (code_type == ELF) {
        Elf64_Ehdr header;
        memcpy(&header, image, sizeof(header));
        size = get_elf_size(&header);
        code = (const void*) image;
    } else if (code_type == ERROR_TYPE) {
        // check whether it's text file of NULL-Terminated AMD GCN File
        // ptx must end with '\0' :)
        const char* ptx = (const char*) image;
        if (ptx[0] == '/' && ptx[1] == '/') {
            size = strlen(ptx); // naturally count till '\0'
            code = (const void*) image;
            code_type = PTX;
        } else { // still unrecognize, report the bug and terminates
            fprintf(event_log, "[mod] hipModuleLoadData unrecognize %d\n", magic);
        }
    } else {
        fprintf(event_log, "[mod] hipModuleLoadData unsupported %s\n", code_types[code_type]);
    }

    // copy the image to a new managed and protected place
    managed_bin = malloc(size);
    memcpy(managed_bin, code, size);

    hipError_t ret = real_hipModuleLoadData(module, image);

    fprintf(event_log, "[mod] hipModuleLoadData mod %p code %p type %s size %zu\n", *module, image, code_types[code_type], size);

    // update to hashmap
    binmap_set(*module, managed_bin, size, NULL); // name = NULL as we don't know it now

    return ret;
}

hipError_t hipModuleLoadDataEx(hipModule_t* module, const void* image, unsigned int numOptions, hipJitOption* options, void** optionValues) {
    if (shared_lib == NULL) { init(); }

    // first parse the image
    int magic, bin_type;
    size_t size;
    const void *code;
    void *managed_bin;
    memcpy(&magic, image, sizeof(int));
    code_types = check_magic(magic);

    if (code_type == ELF) {
        Elf64_Ehdr header;
        memcpy(&header, image, sizeof(header));
        size = get_elf_size(&header);
        code = (const void*) image;
    } else if (code_type == ERROR_TYPE) {
        // check whether it's text file of NULL-Terminated AMD GCN File
        // ptx must end with '\0' :)
        const char* ptx = (const char*) image;
        if (ptx[0] == '/' && ptx[1] == '/') {
            size = strlen(ptx); // naturally count till '\0'
            code = (const void*) image;
            code_type = PTX;
        } else { // still unrecognize, report the bug and terminates
            fprintf(event_log, "[mod] hipModuleLoadData unrecognize %d\n", magic);
        }
    } else {
        fprintf(event_log, "[mod] hipModuleLoadData unsupported %s\n", code_types[code_type]);
    }

    managed_bin = malloc(size);
    memcpy(managed_bin, code, size);

    hipError_t ret = real_hipModuleLoadDataEx(module, image, numOptions, options, optionValues);
    
    fprintf(event_log, "[mod] hipModuleLoadData mod %p code %p type %s size %zu\n", *module, image, code_types[code_type], size);

    // update to hashmap
    binmap_set(*module, managed_bin, size, NULL); // name = NULL as we don't know it now

    return ret;
}

hipError_t hipModuleGetFunction(hipFunction_t* function, hipModule_t module, const char* kname) {
    if (shared_lib == NULL) { init(); }

    // first update the name
    size_t len = strlen(kname);
    char* managed_name = malloc(len);
    memcpy(managed_name, kname, len);
    
    // call real function
    hipError_t result = real_hipModuleGetFunction(function, module, kname);

    fprintf(event_log, "[mod] hipModuleGetFunction func %p mod %p name %s\n", *function, module, kname);

    // then update the key from module to function
    int hash_ret = binmap_update_name_key(module, *function, managed_name);
    if (hash_ret == -1)
        fprintf(event_log, "[hash] hipModuleGetFunction failed-update %p %p %s\n", module, *function, managed_name);
    
    return result;
}

hipError_t hipModuleLaunchKernel(hipFunction_t f, unsigned int gridDimX, unsigned int gridDimY,
                                 unsigned int gridDimZ, unsigned int blockDimX,
                                 unsigned int blockDimY, unsigned int blockDimZ,
                                 unsigned int sharedMemBytes, hipStream_t stream,
                                 void** kernelParams, void** extra) {
    if (shared_lib == NULL) { init(); }
    
    hipEvent_t start_event, end_event;
    HIP_CHECK(real_hipEventCreate(&start_event));
    HIP_CHECK(real_hipEventCreate(&end_event));
    
    HIP_CHECK(real_hipEventRecord(start_event, stream)); // use the stream specified in param

    float prologue_time, kernel_time, epilogue_time;
    hipErrot_t result;
    hipFunction_t probed, pruned;
    char* kernel_name;
    int n_param, n_probe; 
    int* probe_sizes; // size of probes
    int* probe_types; // type of probes
    bool succeed; // jit status
    char* analyze_hook; // path to python script 

    // try obtain the kernel compiled or raise compilation process 
    // @note count and record is only valid if succeed == true
    if (funcmap_get(f, &kernel_name, &n_param, &n_probe, &probe_sizes, &probe_types, &succeed, &probed, &pruned) == -1) {
        fprintf(event_log, "[exec] funcmap-not-find %p\n", f);
        fflush(event_log); // we need many fflush to avoid trace not printed
        // here try to get binary from binmap and start JIT compile
        size_t size;
        void* bin;
        if (binmap_get(f, &size, &kernel_name, &bin) == -1) { // not found the binary, fall back
            fprintf(event_log, "[jit] can't-find %p\n", f);
            fflush(event_log);
            funcmap_set(f,kernel_name, 0, 0, NULL, NULL, false, NULL, NULL); // set dummy with status FALSE
            goto backup;
        } else {
            fprintf(event_log, "[jit] find %p name %s bin %p size %zu\n", f, kernel_name, bin, size);
            fflush(event_log);
            // create a directory under the kernel directory with kernel_name
            // @note Linux has limit on directory length 255, replace it to sh1 so 20 char
            // @bugfix PyTorch kernel name usually is extremely long :(
            // @bugfix Triton autotune leads to a set of kernel with same name -> use counter to differentiate
            char *tmp = sha1(kernel_name);
            char *folder_name = (char*) malloc(5 + strlen(tmp));
            sprintf(folder_name, "%d_%s", kernel_idx, tmp);
            free(tmp);
            kernel_idx++;
            fprintf(event_log, "[jit] rename %s %s\n", kernel_name, folder_name);
            fflush(event_log);
            char* dir = malloc(strlen(KERNEL_DIR) + strlen(folder_name) + 10);
            sprintf(dir, "%s/%s", KERNEL_DIR, folder_name);
            if (mkdir(dir, 0755) == 0) { 
                fprintf(event_log, "[jit] mkdir %s\n", dir);
            } else {
                fprintf(event_log, "[jit] can't-mkdir %s\n", dir);
                    funcmap_set(f, kernel_name, 0, 0, NULL, NULL, false, NULL, NULL); // set status FALSE to prevent recompile fault
                goto backup;
            }
            // create original.bin and write the binary to it
            char* path = malloc(strlen(dir) + 15);
            sprintf(path, "%s/original.bin", dir);
            FILE* original_bin = fopen(path, "wb");
            if (original_bin == NULL) {
                fprintf(event_log, "[jit] can't-open %s\n", path);
                    funcmap_set(f, kernel_name, 0, 0, NULL, NULL, false, NULL, NULL); // set status FALSE to prevent recompile fault
                goto backup;
            }
            fwrite(bin, size, 1, original_bin);
            fclose(original_bin);
            fprintf(event_log, "[jit] write %s\n", path);
            // create subprocess to run process.py, be aware of multi-processing
            pid_t pid = fork();
            if (pid < 0) {
                fprintf(event_log, "[jit] can't-folk\n");
                funcmap_set(f,kernel_name, 0, 0, NULL, NULL, false, NULL, NULL); // set status FALSE to prevent recompile fault
                goto backup;
            } else if (pid == 0) { // child process, run python process.py kernel name
                // python process.py <work_dir> <kernel_name>
                execlp(NEUTRINO_PYTHON, NEUTRINO_PYTHON, NEUTRINO_PROBING_PY, dir, kernel_name, NULL);
                exit(EXIT_FAILURE); // reach here only if exec error -> failure
            } else { // parent process, wait for child
                fprintf(event_log, "[jit] subproc %s %s %s %s\n", NEUTRINO_PYTHON, NEUTRINO_PROBING_PY, dir, kernel_name);
                int status;
                waitpid(pid, &status, 0);
                if (status != EXIT_SUCCESS) { 
                    fprintf(event_log, "[jit] python failed\n");
                    funcmap_set(f,kernel_name, 0, 0, NULL, NULL, false, NULL, NULL); // set dummy with status FALSE
                    goto backup; 
                } else {
                    fprintf(event_log, "[jit] python succeed\n");
                }
            }
            // read the kernel.info from file system
            sprintf(path, "%s/kernel.info", dir);
            char* kernel_info = readf(path, "r");
            // poor parser for kernel.info
            // @todo add checking alignment
            char* kernel_end = strchr(kernel_info, '\n');
            *kernel_end = '\0';
            kernel_name = kernel_info;
            char* start = kernel_end + 1;
            sscanf(start, " %d\n%d\n", &n_param, &n_probe);
            // read sizes and types of probe 
            probe_sizes = malloc(n_probe * sizeof(int));
            probe_types = malloc(n_probe * sizeof(int));
            char* strptr = strchr(strchr(start, '\n') + 1, '\n') + 1;
            for (int idx = 0; idx < n_probe; idx++) {
                sscanf(strptr, "%d,%d\n", &probe_types[idx], &probe_sizes[idx]);
                strptr = strchr(strptr, '\n') + 1;
            }
            // @note read process hook, not yet checked
            char* info_end = strchr(strptr, '\n');
            *info_end = '\0';
            analyze_hook = strptr;
            // here read the 
            fprintf(event_log, "[jit] read %s name %s n_param %d n_probe %d analyze_hook %s\n", path, kernel_name, n_param, n_probe, analyze_hook);
            // load probed.bin -> for collecting runtime info
            sprintf(path, "%s/probed.bin", dir);
            void* probed_bin = readf(path, "rb");
            // load pruned.bin -> for benchmark
            sprintf(path, "%s/pruned.bin", dir);
            void* pruned_bin = readf(path, "rb");
            // then load the binary to module
            hipModule_t probed_mod, pruned_mod;
            HIP_CHECK(real_hipModuleLoadData(&probed_mod,  probed_bin));
            HIP_CHECK(real_hipModuleGetFunction(&probed, probed_mod, kernel_name));
            HIP_CHECK(real_hipModuleLoadData(&pruned_mod,  pruned_bin));
            HIP_CHECK(real_hipModuleGetFunction(&pruned, pruned_mod, kernel_name));
            // add record to hashmap to avoid re-compile 
            funcmap_set(f, kernel_name, n_param, n_probe, probe_sizes, probe_types, true, probed, pruned);
            fprintf(event_log, "[jit] finish %p name %s n_param %d\n", f, kernel_name, n_param);
            fflush(event_log);
            // free memory before we leave
            free(dir);
            free(path);
            free(kernel_info);
            free(probed_bin);
            free(pruned_bin);
            free(folder_name);
            // don't free(probe_sizes) -> used by func-map!!!
            succeed = true;
        }
    }
    // expose the original param
    fprintf(event_log, "[exec] funcmap-find %p %s\n", f, succeed ? "success" : "fail");
    // check the jit status, if failed, goto backup
    if (!succeed) { goto backup; }

    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    long long time = ts.tv_nsec + ts.tv_sec * 1e9;
    fprintf(event_log, "[exec] %lld param ", time);
    for (int i = 0; i < n_param; i++) {
        // @note print raw value -> help check raw number but mostly pointers...
        fprintf(event_log, "%llx ", *(hipDeviceptr_t*)kernelParams[i]);
    } 
    fprintf(event_log, "\n");
    fprintf(event_log, "[exec] grid %u %u %u block %u %u %u shared %u\n", gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ, sharedMemBytes);
    fflush(event_log);

    // here start to calculate memory size for every probe based on grid, block and probe_sizes
    // formula similar to ndarray based on grid, block / warp
    const size_t gridSize = gridDimX * gridDimY * gridDimZ;   
    const size_t blockSize = blockDimX * blockDimY * blockDimZ;
    const size_t warpSize = CDIV(blockSize, WARP_SIZE);
    size_t *probe_real_sizes = malloc(n_probe * sizeof(size_t));
    size_t total_probe_sizes = 0;
    for (int idx = 0; idx < n_probe; idx++) {
        if (probe_types[idx] == PROBE_TYPE_THREAD) {
            probe_real_sizes[idx] = gridSize * blockSize * probe_sizes[idx];
            fprintf(event_log, "[exec] grid %zu block %zu probe %d total %zu\n", gridSize, blockSize, probe_sizes[idx], probe_real_sizes[idx]);
        } else if (probe_types[idx] == PROBE_TYPE_WARP) {
            probe_real_sizes[idx] = gridSize * warpSize * probe_sizes[idx];
            fprintf(event_log, "[exec] grid %zu warp  %zu probe %d total %zu\n", gridSize, warpSize, probe_sizes[idx], probe_real_sizes[idx]);
        }
        total_probe_sizes += probe_real_sizes[idx];
    }

    fprintf(event_log, "[exec] probe-mem %zu (bytes)\n", total_probe_sizes);
    
    // Allocate Memory on Host and Device
    void** h_probe_mems = malloc(n_probe * sizeof(void*));
    hipDeviceptr_t* d_probe_mems = malloc(n_probe * sizeof(hipDeviceptr_t));
    for (int idx = 0; idx < n_probe; idx++) {
        h_probe_mems[idx] = malloc(probe_real_sizes[idx]);
        HIP_CHECK(real_hipMalloc(&d_probe_mems[idx], probe_real_sizes[idx]));
        HIP_CHECK(real_hipMemsetD32(d_probe_mems[idx], 0, probe_real_sizes[idx] / 4UL));
    }
    
    // @note argument layout is (n_param + n_probe) * sizeof(void*), n_param is parsed inside ptx
    void** probe_args = malloc((n_param + n_probe) * sizeof(void*));
    memcpy(probe_args, kernelParams, n_param * sizeof(void*)); // copy the raw parameters
    for (int idx = 0; idx < n_probe; idx++) { 
        probe_args[n_param + idx] = &d_probe_mems[idx]; // offset with n_param -> place later
    }
    /**
     * @note set the shared memory size. If the kernel shared memory size exceed a limit (usually half) 
     * of the physical SMEM size (per SM), then hipModuleLaunchKernel will raise CUDA_ERROR_INVALID_VALUE, we
     * need to manually set via cuFuncSetAttribute(kernel, CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES, shared)
     * 
     * @details Neutrino JIT Function is considered a new one and can not inherit original setup...
     */
    HIP_CHECK(real_hipFuncSetAttribute(probed, hipFuncAttributeMaxDynamicSharedMemorySize, sharedMemBytes));
    if (NEUTRINO_BENCHMARK) {
        real_hipMemsetD32(benchmark_flush_mem, 0, NEUTRINO_BENCHMARK_FLUSH_MEM_SIZE / 4UL);
    }
    HIP_CHECK(real_hipEventRecord(end_event, stream)); // use the stream specified in param
    HIP_CHECK(real_hipEventSynchronize(end_event));
    HIP_CHECK(real_hipEventElapsedTime(&prologue_time, start_event, end_event));
    HIP_CHECK(real_hipEventRecord(start_event, stream)); // use the stream specified in param
    // launch kernel by call real_hipModuleLaunchKernel function
    result = real_hipModuleLaunchKernel(probed, gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, 
                                    blockDimZ, sharedMemBytes, stream, probe_args, extra);
    HIP_CHECK(real_hipEventRecord(end_event, stream)); // use the stream specified in param
    HIP_CHECK(real_hipEventSynchronize(end_event));
    // calculate the real kernel time
    HIP_CHECK(real_hipEventElapsedTime(&kernel_time, start_event, end_event));
    HIP_CHECK(real_hipEventRecord(start_event, stream)); // use the stream specified in param
    if (result != hipSuccess) {
        for (int idx = 0; idx < n_probe; idx++) {
            free(h_probe_mems[idx]);
            HIP_CHECK(real_hipFree(d_probe_mems[idx]));
        }
        free(h_probe_mems);
        free(d_probe_mems);
        free(probe_real_sizes);
        free(probe_args);
        fprintf(event_log, "[exec] failed %d\n", result);
        goto backup;
    } else {
        fprintf(event_log, "[exec] succeed %d\n", result);
    }

    // dump to disk
    for (int idx = 0; idx < n_probe; idx++) {
        HIP_CHECK(real_hipMemcpyDtoH(h_probe_mems[idx], d_probe_mems[idx], probe_real_sizes[idx]));
    }
    // create dump file
    char* DUMP_FILE_NAME = malloc(strlen(RESULT_DIR) + 20);
    struct timespec end;
    clock_gettime(CLOCK_REALTIME, &end);
    double elapsed = ((end.tv_sec * 1e9 + end.tv_nsec) - (start.tv_sec * 1e9 + start.tv_nsec)) / 1e9;
    sprintf(DUMP_FILE_NAME, "%s/%.6f.bin", RESULT_DIR, elapsed);
    FILE *fp = fopen(DUMP_FILE_NAME, "wb");
    if (!fp) { 
        fprintf(event_log, "[exec] can't-save %s\n", DUMP_FILE_NAME); 
        return hipSuccess; // only can't save, still success in execution
    }
    // write header to file
    trace_header_t header;
    // gridDim: uint3
    header.gridDimX = gridDimX;
    header.gridDimY = gridDimY;
    header.gridDimZ = gridDimZ;
    // blockDim: uint3
    header.blockDimX = blockDimX;
    header.blockDimY = blockDimY;
    header.blockDimZ = blockDimZ;
    // sharedMemBytes and numProbes
    header.sharedMemBytes = sharedMemBytes;
    header.numProbes = n_probe;
    fwrite(&header, sizeof(header), 1, fp);
    // write sections to file
    size_t offset = sizeof(header) + n_probe * sizeof(trace_section_t);
    for (int idx = 0; idx < n_probe; idx++) {
        trace_section_t section;
        section.size = probe_real_sizes[idx];
        section.offset = offset;
        offset += section.size;
        fwrite(&section, sizeof(section), 1, fp);
    }
    // write data
    for (int idx = 0; idx < n_probe; idx++) {
        fwrite(h_probe_mems[idx], 1, probe_real_sizes[idx], fp);
    }
    // close file
    fclose(fp);
    fprintf(event_log, "[exec] save %s size %zu\n", DUMP_FILE_NAME, offset);
    // free allocated memory before leave
    for (int idx = 0; idx < n_probe; idx++) {
        free(h_probe_mems[idx]);
        HIP_CHECK(real_hipFree(d_probe_mems[idx]));
    }

    // on leave
    HIP_CHECK(real_hipEventRecord(end_event, stream)); // use the stream specified in param
    HIP_CHECK(real_hipEventSynchronize(end_event));
    HIP_CHECK(real_hipEventElapsedTime(&epilogue_time, start_event, end_event));
    if (NEUTRINO_BENCHMARK)  {
        real_hipMemsetD32(benchmark_flush_mem,0, NEUTRINO_BENCHMARK_FLUSH_MEM_SIZE / 4UL);
        // here Neutrino use pruned ptx being compiled with exactly the same configuration (assmbler & optimization) with probed
        float original_time;
        HIP_CHECK(real_hipFuncSetAttribute(pruned, hipFuncAttributeMaxDynamicSharedMemorySize, sharedMemBytes));
        HIP_CHECK(real_hipEventRecord(start_event, stream)); // use the stream specified in param
        // launch original kernel with original parameter
        result = real_hipModuleLaunchKernel(pruned, gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ, sharedMemBytes, stream, kernelParams, extra);
        HIP_CHECK(real_hipEventRecord(end_event, stream)); // use the stream specified in param
        HIP_CHECK(real_hipEventSynchronize(end_event));
        // calculate the real kernel time
        HIP_CHECK(real_hipEventElapsedTime(&original_time, start_event, end_event));
        fprintf(event_log, "[benchmark] prologue %f kernel %f epilogue %f original %f impact %f %d\n", prologue_time, kernel_time, epilogue_time, original_time, kernel_time / original_time, result);
    } else {
        fprintf(event_log, "[exec] prologue %f kernel %f epilogue %f ratio %f\n", prologue_time, kernel_time, epilogue_time, (prologue_time + kernel_time + epilogue_time) / kernel_time);
    }

    // @note do the analyze_hook if having
    if (strlen(analyze_hook) >= 3 && strcmp(analyze_hook + strlen(analyze_hook) - 3, ".py") == 0) {
        pid_t pid = fork();
        if (pid < 0) {
            fprintf(event_log, "[jit] can't-folk\n");
        } else if (pid == 0) { // child process, run python process.py kernel name
            execlp(NEUTRINO_PYTHON, NEUTRINO_PYTHON, analyze_hook, DUMP_FILE_NAME, NULL);
            exit(EXIT_FAILURE); // reach here only if exec error -> failure
        } else { // parent process, wait for child
            fprintf(event_log, "[analyze] subproc %s %s %s\n", NEUTRINO_PYTHON, analyze_hook, DUMP_FILE_NAME);
            int status;
            waitpid(pid, &status, 0);
            if (status != EXIT_SUCCESS) { 
                fprintf(event_log, "[analyze] failed\n");
            } else {
                fprintf(event_log, "[analyze] succeed\n");
            }
        }
    }
    
    free(h_probe_mems);
    free(d_probe_mems);
    free(probe_real_sizes);
    free(probe_args);
    
    return hipSuccess; // reach here must be hipSuccess

backup:
    // fall back to original version
    fprintf(event_log, "[exec] backup %u %u %u block %u %u %u shared %u\n", gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ, sharedMemBytes);
    result = real_hipModuleLaunchKernel(f, gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ, sharedMemBytes, stream, kernelParams, extra);
    return result;
}

/**
 * Memory API, hooked to be helpful in checking allocated memory region
 */

hipError_t hipMalloc(void **ptr, size_t size) {
    if (shared_lib == NULL)  { init(); } 
    
    hipError_t result = real_hipMalloc(ptr, size);

    fprintf(event_log, "[mem] hipMalloc %d dptr %llx bytesize %zu\n", result, *ptr, size);

    return result;
}


hipError_t hipFree(void *ptr) {
    if (shared_lib == NULL) { init(); } 

    hipError_t result = real_hipFree(ptr);

    fprintf(event_log, "[mem] cuMemFree_v2 %d dptr %llx\n", result, ptr);
    
    return result;
}

// verify if this API is used 
hipError_t hipModuleLoad(hipModule_t *module, const char *fname) {
    if (shared_lib == NULL) { init(); }

    hipError_t result = real_hipModuleLoad(module, fname);

    fprintf(event_log, "[mod] hipModuleLoad %d mod %llx name %s\n", *module, fname);
    
    return result;
}

// just for some parsing error, don't understand why HIP has such weird API
hipError_t hipEventRecord(hipEvent_t event, hipStream_t stream) {
    if (shared_lib == NULL) { init(); }
    hipError_t result = real_hipEventRecord(event, stream);
    return result;
}

const char* hipGetErrorName(hipError_t hip_error) { // Hi AMD, why hip_error here?
    if (shared_lib == NULL) { init(); }
    hipError_t result = real_hipGetErrorName(hip_error);
    return result;
}

const char* hipGetErrorString(hipError_t hipError) { // Hi AMD, why hipError here?
    if (shared_lib == NULL) { init(); }
    hipError_t result = real_hipGetErrorString(hipError);
    return result;
}

const char* hipApiName(uint32_t id) {
    if (shared_lib == NULL) { init(); }
    hipError_t result = real_hipApiName(id);
    return result;
}

const char* hipKernelNameRef(const hipFunction_t f) {
    if (shared_lib == NULL) { init(); }
    hipError_t result = real_hipKernelNameRef(f);
    return result;
}

const char* hipKernelNameRefByPtr(const void* hostFunction, hipStream_t stream) {
    if (shared_lib == NULL) { init(); }
    hipError_t result = real_hipKernelNameRefByPtr(hostFunction, stream);
    return result;
}

/**
 * Unmodified part of code, automatically generated by parse.py
 * usually we don't trace these API, just print a event_log to indicate they're used
 * if there's any weird behavior caused by Neutrino (unlikely), we can have a look
 */
#include "unmodified.c" // include the auto-generated code

// Following are some (now) undocumented API from HIP v4.2
// but they're still in use, at least rocBLAS (dependent of PyToch) will use it

// @see https://github.com/ROCm/hip/blob/rocm-4.2.x/rocclr/hip_platform.cpp#L76
void** __hipRegisterFatBinary(const void* data) {
    if (shared_lib == NULL)  { init(); }
    void** (real___hipRegisterFatBinary*)(const void*) = dlsym(shared_lib, "__hipRegisterFatBinary");

    void** fatbin = real___hipRegisterFatBinary(data);
    if (VERBOSE)  { fprintf(event_log, "[info] __hipRegisterFatBinary %p %p\n", *fatbin, data); }
    return fatbin;
}

// @see https://github.com/ROCm/hip/blob/rocm-4.2.x/rocclr/hip_platform.cpp#L87
void __hipRegisterFunction(
    void** modules,
    const void*  hostFunction,
    char*        deviceFunction,
    const char*  deviceName,
    unsigned int threadLimit,
    uint3*       tid, // There's no official C style Impl of uint3 and dim3, I refer to
    uint3*       bid, // https://rocm.docs.amd.com/projects/HIP/en/docs-5.7.0/reference/kernel_language.html#short-vector-types
    dim3*        blockDim, // so as the dim3
    dim3*        gridDim,  // https://rocm.docs.amd.com/projects/HIP/en/docs-5.7.0/reference/kernel_language.html#dim3
    int*         wSize) {
    if (shared_lib == NULL)  { init(); }
    void (real___hipRegisterFunction*)(void**, const void*, char*, const char*, unsigned int, uint3*, uint3*, dim3*, dim3*, int*) = dlsym(shared_lib, "__hipRegisterFunction");

    real___hipRegisterFunction(modules, hostFunction, deviceFunction, deviceName, threadLimit, tid, bid, blockDim, gridDim, wSize);
    if (VERBOSE)  { fprintf(event_log, "[info] __hipRegisterFunction %p %p\n", *modules, hostFunction); }
}

void __hipUnregisterFatBinary(void** modules) {
    if (shared_lib == NULL)  { init(); }
    void (real___hipUnregisterFatBinary*)(void**) = dlsym(shared_lib, "__hipUnregisterFatBinary");

    real___hipUnregisterFatBinary(modules);
    if (VERBOSE)  { fprintf(event_log, "[info] __hipUnregisterFatBinary %p\n", *modules); }
}